import basic.class04.Code03_CountSort;
import basic.class04.Code04_RadixSort;
import basic.class02.*;
import basic.class10.*;
import basic.class18.Code02_HanoiTower;

public class Readme {

    /**
     * 排序算法
     * <ol>
     *      <li> 冒泡排序 {@link basic.class01.BubbleSort} </li>
     *      <li> 插入排序 {@link basic.class01.InsertSort} </li>
     *      <li> 选择排序 {@link basic.class01.SelectSort} </li>
     *      <li> 快速排序 {@link basic.class03.Code04_QuickSort} </li>
     *      <li> 归并排序 {@link basic.class03.MergeSort} </li>
     *      <li> 堆排序 {@link basic.class04.Code03_HeapSort} </li>
     *      <li> 计数排序 {@link Code03_CountSort} </li>
     *      <li> 基数排序 {@link Code04_RadixSort} </li>
     *      <li> 二分法 {@link basic.class01.BSExist} </li>
     * </ol>
     */
    void sort() {}

    /**
     * 栈、队列、链表
     * <ol>
     *
     * </ol>
     * <li>　删除链表中给定值  {@link basic.class02.DeleteGivenValue}　</li>
     * <li>　反转链表  {@link ReverseList}　</li>
     * <li>　  {@link }　</li>
     * <li>　两链表相交节点  {@link Code01_FindFirstIntersectNode}　</li>
     * <li>　将链表分成 <区，=区，>区  {@link Code02_SmallerEqualBigger}　</li>
     * <li>　判断链表是否是回文结构  {@link Code02_SmallerEqualBigger}　</li>
     *
     */
    void list(){}

    /**
     * 前缀树  {@link basic.class05.Code02_TrieTree}
     */
    void tree(){}

    /**
     * 二叉树
     *
     * <ol>
     *      <li> 遍历二查叉树 {@link basic.class11_binaryTree.Code01_TraversalBinaryTree} </li>
     *      <li> 非递归方式遍历二叉树 {@link basic.class11_binaryTree.Code01_UnRecursiveTraversalBT} </li>
     *      <li> 判断两棵树结构相同 {@link basic.class11_binaryTree.Code02_SameTree} </li>
     *      <li> N 叉树序列化成二叉树 {@link basic.class11_binaryTree.Code03_EncodeNaryTreeToBinaryTree} </li>
     *      <li> 打印二叉树 {@link basic.class11_binaryTree.Code04_PrintBinaryTree} </li>
     *      <li> 计算二叉树最大深度 {@link basic.class11_binaryTree.Code04_MaxDepthOfBinaryTree} </li>
     *      <li> 计算二叉树最大宽度 {@link basic.class11_binaryTree.Code05_TreeMaxWidth} </li>
     *      <li> 知道一棵二叉树的先序遍历和中序遍历，且先序遍历和中序遍历中没有重复值 {@link basic.class11_binaryTree.Code05_ConstructBinaryTreeFromPreorderAndInorderTraversal} </li>
     *      <li> 序列化和反序列化二叉树 {@link basic.class11_binaryTree.Code6_SerializeAndReconstructTree} </li>
     *      <li> 给定二叉树中的某个节点 x，返回该节点的后继节点  {@link basic.class11_binaryTree.Code06_SuccessorNode} </li>
     *      <li> 纸条折叠  {@link basic.class11_binaryTree.Code07_PaperFolding} </li>
     * </ol>
     *
     */
    void binaryTree(){}

    /**
     * 并查集 {@link basic.class16_unionFind.Code05_UnionFind}
     */
    void union(){}


    /**
     * 图 {@link basic.class17.Graph}
     * DFS、BFS、拓扑排序、最小生成树 Kruskal、Prim
     */
    void graph(){}

    /**
     * 递归
     *
     * <ol>
     *     <li> 汉诺塔问题 {@link Code02_HanoiTower} </li>
     *     <li> 打印一个字符串的全部子序列 {@link basic.class18.Code03_PrintAllSubsquences} </li>
     *     <li> 打印一个字符串的全部排列 {@link basic.class18.Code04_PrintAllPermutations} </li>
     *     <li> 不申请额外的数据结构，逆序这个栈 {@link basic.class18.Code05_ReverseStackUsingRecursive} </li>
     * </ol>
     *
     */
    void reverse(){}

    /**
     * 动态规划 class19-class26
     *
     * <ol>
     *     <li> 机器人问题  {@link basic.class19_dp.Code01_RobotWalk} </li>
     *     <li> 取分数最大问题 {@link basic.class19_dp.Code02_CardsInLine} </li>
     *
     *     <li> 背包问题 {@link basic.class20.Code01_Knapsack} </li>
     *     <li> 数字字符串转换为字符 {@link basic.class20.Code02_ConvertToLetterString} </li>
     *     <li> 贴纸问题 {@link basic.class20.Code03_StickersToSpellWord} </li>
     *     <li> 最长公共子序列 {@link basic.class20.Code04_LongestCommonSubsequence} </li>
     *
     *     <li> 最长回文子序列 {@link basic.class21.Code01_PalindromeSubsequence} </li>
     *     <li> 象棋中马跳到目标位置 {@link basic.class21.Code02_HorseJump} </li>
     *     <li> 洗咖啡机问题 {@link basic.class21.Code03_Coffee} </li>
     *
     *     <li> 最短路径问题 {@link basic.class22.Code01_MinPathSum} </li>
     *     <li> 货币数组 {@link basic.class22.Code02_CoinsWayEveryPaperDifferent} </li>
     *     <li> 面值数组 {@link basic.class22.Code03_CoinsWayNoLimit} </li>
     *     <li> 面值数组 {@link basic.class22.Code04_CoinsWaySameValueSamePapper} </li>
     *     <li> 棋盘存活率 {@link basic.class22.Code05_BobDie} </li>
     *
     *     <li> 怪兽死亡率 {@link basic.class23.Code01_KillMonster} </li>
     *     <li> 组成目标货币面值所需货币数 {@link basic.class23.Code02_MinCoinsNoLimit} </li>
     *     <li> 正数拆分 {@link basic.class23.Code03_SplitNumber} </li>
     *
     *     <li> 改背包问题 {@link basic.class24.Code01_SplitSumClosed} </li>
     *     <li> 拆分数组2 {@link basic.class24.Code02_SplitSumClosedSizeHalf} </li>
     *     <li> N 皇后问题 {@link basic.class24.Code03_NQueens} </li>
     * </ol>
     */
    void test(){}

    /**
     * 滑动窗口
     * {@link basic.class25.Code01_SlidingWindowMaxArray}
     *
     */
    void slidingWindow(){}

    /**
     * 单调栈
     */
    void monotonousStack(){}

    /**
     * KMP 算法
     *
     * {@link basic.class28.Code01_KMP}
     */
    void kmp(){}

    /**
     * manacher 算法
     * <ol>
     *     <li> {@link basic.class29.Code01_Manacher} </li>
     * </ol>
     */
    void manacher(){}

    /**
     * bfprt 算法
     *
     * 在无序数组中求第 K 小的数 {@link basic.class30.Code01_FindMinKth}
     * 给定一个无序数组 arr 中，长度为 N，给定一个正数 k，返回 top k 个最大的数 {@link basic.class30.Code02_MaxTopK}
     */
    void bfprt(){}

    /**
     * 蓄水池算法 {@link basic.class30.Code03_ReservoirSampling}
     */
    void reservoirSampling(){}

    /**
     * Morris 遍历  {@link basic.class31.Code01_MorrisTraversal}
     */
    void morris(){}

    /**
     * 线段树 {@link basic.class32.Code01_SegmentTree}
     */
    void segmentTree(){}

    /**
     * 有序表
     *
     * <ol>
     *     <li> AVL 树 {@link basic.class36.Code01_AVLTreeMap.AVLTreeMap} </li>
     *     <li> SB 树 {@link basic.class36.Code01_SizeBalancedTreeMap} </li>
     *     <li> 跳表  {@link basic.class36.Code02_SkipListMap} </li>
     * </ol>
     */
    void treeMap(){}
}
