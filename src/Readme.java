import basic.class04.Code03_CountSort;
import basic.class04.Code04_RadixSort;
import basic.class02.*;
import basic.class10.*;

public class Readme {

    /**
     * 排序算法
     * <ol>
     *      <li> 冒泡排序 {@link basic.class01.BubbleSort} </li>
     *      <li> 插入排序 {@link basic.class01.InsertSort} </li>
     *      <li> 选择排序 {@link basic.class01.SelectSort} </li>
     *      <li> 快速排序 {@link basic.class03.Code04_QuickSort} </li>
     *      <li> 归并排序 {@link basic.class03.MergeSort} </li>
     *      <li> 堆排序 {@link basic.class04.Code03_HeapSort} </li>
     *      <li> 计数排序 {@link Code03_CountSort} </li>
     *      <li> 基数排序 {@link Code04_RadixSort} </li>
     *      <li> 二分法 {@link basic.class01.BSExist} {@link primary.class03.Code01_BSExist}</li>
     * </ol>
     */
    void sort() {}

    /**
     * 栈、队列、链表
     * <ol>
     *
     * </ol>
     * <li>　删除链表中给定值  {@link basic.class02.DeleteGivenValue}　</li>
     * <li>　反转链表  {@link ReverseList}　</li>
     * <li>　  {@link }　</li>
     * <li>　两链表相交节点  {@link Code01_FindFirstIntersectNode}　</li>
     * <li>　将链表分成 <区，=区，>区  {@link Code02_SmallerEqualBigger}　</li>
     * <li>　判断链表是否是回文结构  {@link Code02_SmallerEqualBigger}　</li>
     *
     */
    void list(){}

    /**
     * 前缀树  {@link basic.class05.Code02_TrieTree}
     */
    void tree(){}

    /**
     * 二叉树
     *
     * <ol>
     *      <li> 遍历二查叉树 {@link basic.class11.Code01_TraversalBinaryTree} </li>
     *      <li> 非递归方式遍历二叉树 {@link basic.class11.Code01_UnRecursiveTraversalBT} </li>
     *      <li> 判断两棵树结构相同 {@link basic.class11.Code02_SameTree} </li>
     *      <li> 计算二叉树最大深度 {@link basic.class11.Code04_MaxDepthOfBinaryTree} </li>
     *      <li> 知道一棵二叉树的先序遍历和中序遍历，且先序遍历和中序遍历中没有重复值 {@link basic.class11.Code05_ConstructBinaryTreeFromPreorderAndInorderTraversal} </li>
     * </ol>
     *
     */
    void binaryTree(){}

    /**
     * 并查集 {@link basic.class16.Code05_UnionFind}
     */
    void union(){}


    /**
     * 图 {@link basic.class17.Graph}
     * DFS、BFS、拓扑排序、最小生成树 Kruskal、Prim
     */
    void graph(){}

    /**
     * 递归
     *
     * <ol>
     *     <li> 汉诺塔问题 {@link basic.class18.Code02_Hanoi} </li>
     *     <li> 打印一个字符串的全部子序列 {@link basic.class18.Code03_PrintAllSubsquences} </li>
     *     <li> 打印一个字符串的全部排列 {@link basic.class18.Code04_PrintAllPermutations} </li>
     *     <li> 不申请额外的数据结构，逆序这个栈 {@link basic.class18.Code05_ReverseStackUsingRecursive} </li>
     * </ol>
     *
     */
    void reverse(){}

    /**
     * 动态规划
     *
     * <ol>
     *     <li> 机器人问题  {@link basic.class19.Code01_RobotWalk} </li>
     *     <li> 取分数最大问题 {@link basic.class19.Code02_CardsInLine} </li>
     *
     *     <li> 背包问题 {@link basic.class20.Code01_Knapsack} </li>
     *     <li> 数字字符串转换为字符 {@link basic.class20.Code02_ConvertToLetterString} </li>
     *     <li> 贴纸问题 {@link basic.class20.Code03_StickersToSpellWord} </li>
     *     <li> 最长公共子序列 {@link basic.class20.Code04_LongestCommonSubsequence} </li>
     *
     *     <li> 最长回文子序列 {@link basic.class21.Code01_PalindromeSubsequence} </li>
     *     <li> 象棋中马跳到目标位置 {@link basic.class21.Code02_HorseJump} </li>
     *     <li> 洗咖啡机问题 {@link basic.class21.Code03_Coffee} </li>
     *
     *     <li> 最短路径问题 {@link basic.class21.Code03_Coffee} </li>
     *
     * </ol>
     */
    void test(){}

    /**
     * 滑动窗口
     * {@link basic.class25.Code01_SlidingWindowMaxArray}
     *
     */
    void slidingWindow(){}

    /**
     * 单调栈
     */
    void monotonousStack(){}

    /**
     * KMP 算法
     *
     * {@link basic.class28.Code01_KMP}
     */
    void kmp(){}

    /**
     * manacher 算法
     * <ol>
     *     <li> {@link basic.class29.Code01_Manacher} </li>
     * </ol>
     */
    void manacher(){}

    /**
     * bfprt 算法，蓄水池算法
     */
    void bfprt(){}

    /**
     * Morris 遍历  {@link basic.class31.Code01_MorrisTraversal}
     */
    void morris(){}

    /**
     * 线段树 {@link basic.class32.Code01_SegmentTree}
     */
    void segmentTree(){}

    /**
     * 有序表
     * <ol>
     *     <li> SB 树 {@link basic.class37.Code01_SizeBalancedTreeMap} </li>
     *     <li> 跳表  {@link basic.class37.Code02_SkipListMap} </li>
     * </ol>
     */
    void treeMap(){}
}
